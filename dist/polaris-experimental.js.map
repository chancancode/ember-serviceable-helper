{"version":3,"file":"polaris-experimental.js","sources":["../src/polaris-experimental.ts"],"sourcesContent":["import type { Scope, ServiceFactory } from 'ember-polaris-service';\nimport { getScope, setScope, lookup } from 'ember-polaris-service';\n\nimport type {\n  AnyFunction,\n  InjectableConstructor,\n  InjectableFunction,\n  Injected,\n} from './types.ts';\nimport { constructorFor } from './injection.ts';\nimport type { GetInjections } from './injection.ts';\nimport { helperFor } from './manager.ts';\n\ntype WithScope = { scope: Scope };\n\ntype InjectScope<Injections> = Inject<Injections & Scope>;\n\ntype WithProperty<K extends keyof object, V> = { [P in K]: V };\n\ntype InjectProperty<Injections, K extends keyof object, V> = Inject<\n  Injections & WithProperty<K, V>\n>;\n\nconst UNINITIALIZED = Symbol('UNINITIALIZED');\ntype UNINITIALIZED = typeof UNINITIALIZED;\n\n/**\n * A builder DSL to build the injections needed for a function\n */\nexport interface Inject<Injections> {\n  /**\n   * Inject the scope as `this.scope`\n   */\n  scope(): InjectScope<Injections>;\n\n  /**\n   * Inject `lookup(scope, factory)` as `this[name]`\n   *\n   * @param name name of the property\n   * @param factory the lookup token/factory for the service\n   */\n  service<K extends keyof object, V>(\n    name: K,\n    factory: ServiceFactory<V>,\n  ): InjectProperty<Injections, K, V>;\n\n  /**\n   * Inject an arbitrary property with a value determined by the callback\n   *\n   * @param name name of the property\n   * @param callback a callback returning the value of the injected property\n   */\n  property<K extends keyof object, V>(\n    name: K,\n    callback: (this: Injections, owner: Scope) => V,\n  ): InjectProperty<Injections, K, V>;\n\n  /**\n   * Finalize the injections, returning an instantiable version of the given\n   * function\n   *\n   * @param fn the function that should receive these injections\n   */\n  into<F extends InjectableFunction<Injections>>(\n    fn: F,\n  ): InjectableConstructor<Injected<F>, Scope>;\n\n  /**\n   * Finalize the injections with a callback that, given the injections,\n   * returns the instantiated function\n   */\n  build<F extends AnyFunction>(\n    callback: (injections: Injections) => F,\n  ): InjectableConstructor<F, Scope>;\n}\n\ntype DefineInjectedProperty = (scope: Scope, injections: object) => void;\n\nclass Builder<Injections> implements Inject<Injections> {\n  constructor(\n    private readonly properties: readonly DefineInjectedProperty[] = [],\n  ) {}\n\n  scope(): InjectScope<Injections> {\n    return new Builder<Injections & WithScope>([\n      ...this.properties,\n      (scope, injections) => {\n        Object.defineProperty(injections, 'scope', {\n          get(): Scope {\n            return scope;\n          },\n        });\n      },\n    ]);\n  }\n\n  service<K extends keyof object, V>(\n    name: K,\n    factory: ServiceFactory<V>,\n  ): InjectProperty<Injections, K, V> {\n    return new Builder<Injections & WithProperty<K, V>>([\n      ...this.properties,\n      (scope, injections) => {\n        let service: V | UNINITIALIZED = UNINITIALIZED;\n        Object.defineProperty(injections, name, {\n          get(): V {\n            if (service === UNINITIALIZED) {\n              service = lookup(scope, factory);\n            }\n            return service;\n          },\n        });\n      },\n    ]);\n  }\n\n  property<K extends keyof object, V>(\n    name: K,\n    callback: (this: Injections, scope: Scope) => V,\n  ): InjectProperty<Injections, K, V> {\n    return new Builder<Injections & WithProperty<K, V>>([\n      ...this.properties,\n      (scope, injections) => {\n        let value: V | UNINITIALIZED = UNINITIALIZED;\n        Object.defineProperty(injections, name, {\n          get(): V {\n            if (value === UNINITIALIZED) {\n              value = callback.call(this, scope);\n            }\n            return value;\n          },\n        });\n      },\n    ]);\n  }\n\n  into<F extends InjectableFunction<Injections>>(\n    fn: F,\n  ): InjectableConstructor<Injected<F>, Scope> {\n    const getInjections = this.getInjections();\n    const getInjected = (injections: Injections) => fn.bind(injections);\n    return helperFor(\n      constructorFor(getInjections, getInjected, getScope, fn.name),\n    );\n  }\n\n  build<F extends AnyFunction>(\n    getInjected: (injections: Injections) => F,\n  ): InjectableConstructor<F, Scope> {\n    const getInjections = this.getInjections();\n    return helperFor(\n      constructorFor(getInjections, getInjected, getScope, getInjected.name),\n    );\n  }\n\n  private getInjections(): GetInjections<Injections, Scope> {\n    const { properties } = this;\n\n    return (scope) => {\n      const injections = {};\n\n      for (const defineProperty of properties) {\n        defineProperty(scope, injections);\n      }\n\n      setScope(injections, scope);\n\n      return Object.freeze(injections) as Injections;\n    };\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport default new Builder() as Inject<{}>;\n\nexport type { InjectableFunction, Injected, InjectableConstructor };\n"],"names":["UNINITIALIZED","Symbol","Builder","constructor","properties","scope","injections","Object","defineProperty","get","service","name","factory","lookup","property","callback","value","call","into","fn","getInjections","getInjected","bind","helperFor","constructorFor","getScope","build","setScope","freeze"],"mappings":"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"}